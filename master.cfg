# -*- python -*-
# ex: set syntax=python:

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# We store the passwords for the buildslaves in a separate file, so we
# can share this one more widely. Thanks to https://svn.torproject.org/svn/projects/buildbot/trunk/master.cfg
PASSWORD_FILE = "passwords.py"

d = {}
execfile(PASSWORD_FILE, d)
PASSWORDS = d['PASSWORDS']
del d

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
slave_name = "localhost_slave"
c['slaves'] = [BuildSlave(slave_name, PASSWORDS[slave_name])]

# 'protocols' contains information about protocols which master will use for
# communicating with slaves.
# You must define at least 'port' option that slaves could connect to your master
# with this protocol.
# 'port' must match the value configured into the buildslaves (with their
# --master option)
PORT_WEB = 8010           # Buildbot webserver port
PORT_MASTER = 9989      # Port where buildbot master listen buildworkers

c['protocols'] = {'pb': {'port': PORT_MASTER}}

####### CHANGESOURCES
# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

github_repos_username = 'leapcode'
default_branch = 'develop'
order_repos_index = 2
REPOS=[
    ('leap_pycommon', default_branch, 1, 'leap.common'),
    ('soledad', default_branch, 2, 'leap.soledad'),
    ('keymanager', default_branch, 3, 'leap.keymanager'),
    ('leap_mail', default_branch, 4, 'leap.mail'),
    ('bitmask_client', default_branch, 5, 'leap.bitmask'),
]

def github_repo_url(repo_name):
    return 'https://github.com/' + github_repos_username + '/' + repo_name + '.git'

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

from buildbot.schedulers.basic import AnyBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.changes.filter import ChangeFilter
c['schedulers'] = []

for repo_name, repo_branch, _, _ in REPOS:
    c['schedulers'].append(AnyBranchScheduler(
        name=repo_name,
        change_filter = ChangeFilter(repository=github_repo_url(repo_name)),
        builderNames=['builder_' + repo_name]))

    c['schedulers'].append(ForceScheduler(
        name="force_build_of_" + repo_name,
        builderNames=['builder_' + repo_name]))

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.config import BuilderConfig

def add_repo_to_factory(factory, repo_name, git_branch, namespace, venv_name):
    install_requirements = 'pkg/pip_install_requirements.sh'
    install_requirements_tests = "if [ -f pkg/requirements-testing.pip ]; then pip install --upgrade -r pkg/requirements-testing.pip; fi"
    install = "python setup.py develop"

    workdir = "workdir-" + repo_name
    sandbox_path = {'PATH':  "../" + venv_name + '/bin/' + ':${PATH}'}
    sandbox_path_soledad = {'PATH':  "../../" + venv_name + '/bin/' + ':${PATH}'}
    repo_url = github_repo_url(repo_name)

    factory.addSteps([
        Git(repourl=repo_url, branch=git_branch, workdir=workdir, mode='incremental', method='clean', haltOnFailure=True, name="Pull " + repo_url),
        ShellCommand(command=['pep8', '--exclude=setup.py,versioneer.py,src._version', '--ignore=E501', '.'],env=sandbox_path,haltOnFailure=False, workdir=workdir, name="pep8 on " + repo_name)
    ])
    if 'bitmask_client' in repo_name:
        factory.addStep(ShellCommand(command='pkg/postmkvenv.sh',env=sandbox_path,haltOnFailure=False, workdir=workdir, name="postmkenv"))
    if 'soledad.git' in repo_url:
        for subpackage in ["common", "client", "server"]:
            factory.addSteps([
                ShellCommand(command=install_requirements, env=sandbox_path_soledad, haltOnFailure=True, workdir=workdir+'/'+subpackage, name="reqs: " + repo_name+"."+subpackage),
                ShellCommand(command=install_requirements_tests, env=sandbox_path_soledad, haltOnFailure=True, workdir=workdir+'/'+subpackage, name="test reqs: " + repo_name+"."+subpackage),
                ShellCommand(command=install, env=sandbox_path_soledad, haltOnFailure=True, workdir=workdir+'/'+subpackage, name="Install " + repo_name+"."+subpackage)
            ])
    else:
        factory.addSteps([
            ShellCommand(command=install_requirements, env=sandbox_path, haltOnFailure=False, workdir=workdir, name="reqs: " + repo_name),
            ShellCommand(command=install_requirements_tests, env=sandbox_path, haltOnFailure=False, workdir=workdir, name="test reqs: " + repo_name),
            ShellCommand(command=install, env=sandbox_path, haltOnFailure=True, workdir=workdir, name="Install " + repo_name)
        ])

def create_builder(repo_name):
    builder_name = 'builder_' + repo_name
    venv_name = "virtualenv_ci_" + builder_name
    venv_path = {'PATH':  "./" + venv_name + '/bin' + ':${PATH}'}
    venv_path_factory = {'PATH':  "../" + venv_name + '/bin' + ':${PATH}'}

    factory = BuildFactory()
    factory.addSteps([
        ShellCommand(command=["rm", "-rf", venv_name], haltOnFailure=True, workdir=".", name="Remove previous virtualenv"),
        ShellCommand(command=["virtualenv", "--python=python2", venv_name], haltOnFailure=True, workdir=".", name="Create new virtualenv"),
        ShellCommand(command=['pip', 'install', '-U', 'pip', 'setuptools'], env=venv_path, workdir=".", name="Update setuptools"),
        ShellCommand(command=['pip', 'install', '--upgrade', 'pep8'], env=venv_path, workdir=".", name="Install pep8")
    ])

    repo_index = [repo[order_repos_index] for repo in REPOS if repo[0] is repo_name][0]
    for repo_name, repo_branch, _, namespace, in sorted(REPOS, key = lambda repo: repo[order_repos_index])[0:repo_index]:
        add_repo_to_factory(factory, repo_name, repo_branch, namespace, venv_name)

    if namespace is not '':
        factory.addStep(ShellCommand(command=['trial', namespace], env=venv_path_factory, workdir="workdir-" + repo_name, name="trial "+namespace))

    return BuilderConfig(name=builder_name, slavenames=[slave_name], factory=factory)

c['builders'] = []

for repo_name, _, _, _ in REPOS:
    c['builders'].append(create_builder(repo_name))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

webinterface_username = "web_interface"
c['www'] = dict(port=PORT_WEB,
                plugins=dict(waterfall_view={}, console_view={}),
                change_hook_dialects={'github': { }})

####### PROJECT IDENTITY

import ConfigParser
config = ConfigParser.ConfigParser()
config.read('conf.cfg')

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = config.get('Buildbot', 'title')
c['titleURL'] = "https://github.com/leapcode/bitmask_client"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = config.get('Buildbot', 'url')

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
