# -*- python -*-
# ex: set syntax=python:

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# We store the passwords for the buildslaves in a separate file, so we
# can share this one more widely. Thanks to https://svn.torproject.org/svn/projects/buildbot/trunk/master.cfg
PASSWORD_FILE = "passwords.py"

d = {}
execfile(PASSWORD_FILE, d)
PASSWORDS = d['PASSWORDS']
del d

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
slave_name = "localhost_slave"
c['slaves'] = [BuildSlave(slave_name, PASSWORDS[slave_name])]

# 'protocols' contains information about protocols which master will use for
# communicating with slaves.
# You must define at least 'port' option that slaves could connect to your master
# with this protocol.
# 'port' must match the value configured into the buildslaves (with their
# --master option)
PORT_WEB = 8010           # Buildbot webserver port
PORT_GITHUB = 8011      # Buildbot github hook port
PORT_MASTER = 9989      # Port where buildbot master listen buildworkers

c['protocols'] = {'pb': {'port': PORT_MASTER}}

####### CHANGESOURCES
# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

github_repos_username = 'parmegv'
github_repos_beginning = 'https://github.com/' + github_repos_username + '/'
default_branch = 'develop'
order_repos_index = 3
REPOS=[
    ('leap_pycommon', default_branch, github_repos_beginning + 'leap_pycommon.git', 1, ''),
    ('keymanager', default_branch, github_repos_beginning + 'keymanager.git', 2, 'leap.keymanager'),
    ('soledad', default_branch, github_repos_beginning + 'soledad.git', 3, ''),
    ('leap_mail', default_branch, github_repos_beginning + 'leap_mail.git', 4, 'leap.mail')
]

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

from buildbot.schedulers.basic import AnyBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.changes.filter import ChangeFilter
c['schedulers'] = []

index = 1
for repo_name, repo_branch, repo_url, _, _ in REPOS:
    c['schedulers'].append(AnyBranchScheduler(
        name=repo_name,
        change_filter = ChangeFilter(repository=repo_url),
        builderNames=['builder_' + str(index)]))

    c['schedulers'].append(ForceScheduler(
        name="force" + str(index),
        builderNames=['builder_' + str(index)]))
    index = index + 1

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.config import BuilderConfig
from buildbot import locks

def add_repo_to_factory(factory, repo_url, venv_name):
    print('add_repo_to_factory', factory, repo_url, venv_name)
    setup_py_install = "python" + " " + "setup.py" + " " + "install"
    sandboxed_setup_install_soledad = ["bash", "-c", "source ../" + venv_name + "/bin/activate" + " && " + setup_py_install]
    sandboxed_setup_install = ["bash", "-c", "source " + venv_name + "/bin/activate" + " && " + setup_py_install]
    
    factory.addStep(ShellCommand(command="rm -rf build", haltOnFailure=True))
    factory.addStep(Git(repourl=repo_url, mode='incremental', method='fresh', haltOnFailure=True))
    if 'soledad.git' in repo_url:
        factory.addStep(ShellCommand(command=sandboxed_setup_install_soledad, haltOnFailure=True, workdir="build/common"))
        factory.addStep(ShellCommand(command=sandboxed_setup_install_soledad, haltOnFailure=True, workdir="build/client"))
        factory.addStep(ShellCommand(command=sandboxed_setup_install_soledad, haltOnFailure=True, workdir="build/server"))
    else:
        factory.addStep(ShellCommand(command=sandboxed_setup_install, haltOnFailure=True))

def create_builder(repo_index):
    print('create_builder(' + str(repo_index) + ')')
    builder_name = 'builder_' + str(repo_index)
    print('builder_name', builder_name)
    venv_name = "virtualenv_ci_" + builder_name
    factory = BuildFactory()
    virtualenv_command = ["virtualenv", "--python=python2", "--clear", venv_name]

    factory.addStep(ShellCommand(command=virtualenv_command, haltOnFailure=True))
    for repo_name, repo_branch, repo_url, _, namespace, in sorted(REPOS, key = lambda repo: repo[order_repos_index])[0:repo_index]:
        add_repo_to_factory(factory, repo_url, venv_name)
        if namespace is not '':
            factory.addStep(ShellCommand(command=["bash", "-c", "source " + venv_name + "/bin/activate" + " && " + "trial " + namespace]))
    
    return BuilderConfig(name=builder_name, slavenames=[slave_name], factory=factory)

exclusive_slave_lock = locks.SlaveLock("exclusive")
c['builders'] = []

index = 1
for repo_name, _, _, _, _ in REPOS:
    c['builders'].append(create_builder(index))
    index = index + 1
print(c['builders'])
####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

webinterface_username = "web_interface"
c['www'] = dict(port=PORT_WEB,
                plugins=dict(waterfall_view={}, console_view={}),
                change_hook_dialects={'github': { }})

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Bitmask Client"
c['titleURL'] = "https://github.com/leapcode/bitmask_client"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://larevoluciondelamor.es:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
