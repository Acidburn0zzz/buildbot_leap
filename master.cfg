# -*- python -*-
# ex: set syntax=python:

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}
builder_name = "bitmask client tests"

####### BUILDSLAVES

# We store the passwords for the buildslaves in a separate file, so we
# can share this one more widely. Thanks to https://svn.torproject.org/svn/projects/buildbot/trunk/master.cfg
PASSWORD_FILE = "passwords.py"

d = {}
execfile(PASSWORD_FILE, d)
PASSWORDS = d['PASSWORDS']
del d

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
slave_name = "localhost_slave"
c['slaves'] = [BuildSlave(slave_name, PASSWORDS[slave_name])]

# 'protocols' contains information about protocols which master will use for
# communicating with slaves.
# You must define at least 'port' option that slaves could connect to your master
# with this protocol.
# 'port' must match the value configured into the buildslaves (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

github_repos_username = 'parmegv'
github_repos_beginning = 'https://github.com/' + github_repos_username + '/'
default_branch = 'develop'
order_repos_index = 3
REPOS=[
    ('leap_pycommon', default_branch, github_repos_beginning + 'leap_pycommon.git', 1),
    ('keymanager', default_branch, github_repos_beginning + 'keymanager.git', 2),
    ('soledad', default_branch, github_repos_beginning + 'soledad.git', 3),
    ('leap_mail', default_branch, github_repos_beginning + 'leap_mail.git', 4)
]

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []
for repo_name, repo_branch, repo_url, _ in REPOS:
    c['change_source'].append(GitPoller(
        repo_url,
        workdir='gitpoller-workdir-%s' % repo_name,
        branch=repo_branch,
        pollinterval=300))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.changes import filter
c['schedulers'] = []

for repo_name, repo_branch, _, _ in REPOS:
    c['schedulers'].append(SingleBranchScheduler(
        name=repo_name,
        change_filter=filter.ChangeFilter(category=repo_name, branch=repo_branch),
        treeStableTimer=None,
        builderNames=[builder_name]))

c['schedulers'].append(ForceScheduler(
    name="force",
    builderNames=[builder_name]))

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.config import BuilderConfig
from buildbot import locks

exclusive_slave_lock = locks.SlaveLock("exclusive")
c['builders'] = []

venv_name = "virtualenv_ci"
factory = BuildFactory()
virtualenv_command = ["virtualenv", "--python=python2", "--clear", venv_name]
setup_py_install = "python" + " " + "setup.py" + " " + "install"
sandboxed_setup_install_soledad = ["bash", "-c", "source ../" + venv_name + "/bin/activate" + " && " + setup_py_install]
sandboxed_setup_install = ["bash", "-c", "source " + venv_name + "/bin/activate" + " && " + setup_py_install]

factory.addStep(ShellCommand(command=virtualenv_command, haltOnFailure=True))
for repo_name, repo_branch, repo_url,_ in sorted(REPOS, key = lambda repo: repo[order_repos_index]):
    factory.addStep(Git(repourl=repo_url, mode='incremental', method='copy', branch=repo_branch, haltOnFailure=True))
    if repo_name == "soledad":
        factory.addStep(ShellCommand(command=sandboxed_setup_install_soledad, haltOnFailure=True, workdir="build/common"))
        factory.addStep(ShellCommand(command=sandboxed_setup_install_soledad, haltOnFailure=True, workdir="build/client"))
        factory.addStep(ShellCommand(command=sandboxed_setup_install_soledad, haltOnFailure=True, workdir="build/server"))
    else:
        factory.addStep(ShellCommand(command=sandboxed_setup_install, haltOnFailure=True))
    
factory.addStep(ShellCommand(command=["bash", "-c", "source " + venv_name + "/bin/activate" + " && " + "trial leap.mail"]))
factory.addStep(ShellCommand(command=["bash", "-c", "source " + venv_name + "/bin/activate" + " && " + "trial leap.keymanager"]))

c['builders'].append(
    BuilderConfig(name=builder_name,
                  slavenames=[slave_name],
		  factory=factory))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth

webinterface_username = "web_interface"
authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth([(webinterface_username, PASSWORDS[webinterface_username])]),
    gracefulShutdown = False,
    forceBuild = 'auth', # use this to test your slave once it is set up
    forceAllBuilds = False,
    pingBuilder = False,
    stopBuild = False,
    stopAllBuilds = False,
    cancelPendingBuild = False,
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Bitmask Client"
c['titleURL'] = "https://github.com/leapcode/bitmask_client"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://localhost:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
